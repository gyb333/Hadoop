JVM的线程数量限制瓶颈问题:　在大型分布式系统中，采用事件监听机制是最常见的。为什么要使用事件监听机制？
假如SparkUI采用Scala的函数调用方式，那么随着整个集群规模的增加，对函数的调用会越来越多，
最终会受到Driver所在JVM的线程数量限制而影响监控数据的更新，甚至出现监控数据无法及时显示给用户的情况。
由于函数调用多数情况下是同步调用，这就导致线程被阻塞，在分布式环境中，还可能因为网络问题，
导致线程被长时间占用。将函数调用更换为发送事件，事件的处理是异步的，当前线程可以继续执行后续逻辑，
线程池中的线程还可以被重用，这样整个系统的并发度会大大增加。发送的事件会存入缓存，由定时调度器取出后，
分配给监听此事件的监听器对监控数据进行更新。



EventBus: 是常用的消息传递的方式之一，其他常见的消息传递的方式还包括 Handler、BroadcastReceiver、Listener。
遇见使用异步的方式来发送事件，或者触发另外一个动作：经常用到的框架是MQ（分布式方式通知）。
如果是同一个jvm里面通知的话，就可以使用EventBus。

事件的发布和订阅是强一致性的，两者在同一个处理过程中，当出现错误，触发事件方和订阅方的数据会一起回滚。
不管是领域内事件还是跨领域事件，在EventBus触发事件之后，都会选择将消息持久化到业务数据库。

1.一个大的领域内的各小模块之间的事件的触发和订阅

2.跨领域（跨JVM进程）之间的事件订阅:消息持久化到DB，定时任务Kafka，RabbitMQ生产者订阅
https://github.com/leihuazhe?utf8=%E2%9C%93&tab=repositories&q=event-bus&type=&language=
https://github.com/dapeng-soa/dapeng-event-bus
https://www.jianshu.com/p/d2b1ce0a9f60
https://www.jianshu.com/p/f89741097113


分布式系统IO操作瓶颈问题：在Linux操作系统层面，网络操作即为IO操作，总共有：阻塞式，非阻塞式，复用模型，信号驱动和异步五种IO模型。其中
阻塞式IO操作请求发起以后，从网卡等待/读取数据，内核/到用户态的拷贝，整个IO过程中，用户的线程都是处于阻塞状态。
非阻塞与阻塞的区别在于应用层不会等待网卡接收数据，即在内核数据未准备好之前，IO将返回EWOULDBLOCK，用户端通过主动轮询，直到内核态数据准备好，然后再主动发起内核态数据到用户态的拷贝读操作（阻塞）。
在非阻塞IO中，每个IO的应用层代码都需要主动地去内核态轮询直到数据OK，在IO复用模型中，将“轮询/事件驱动”的工作交给一个单独的select/epoll的IO句柄去做，即所谓的IO复用。
信号驱动IO是向内核注册信号回调函数，在数据OK的时候自动触发回调函数，进而可以在回调函数中启用数据的读取，即由内核告诉我们何时可以开始IO操作。
异步IO是将IO数据读取到用户态内存的函数注册到系统中，在内核数据OK的时候，自动完成内核态到用户态的拷贝，并通知应用态数据已经读取完成，即由内核告诉我们何时IO操作已经完成；
Akka Netty


